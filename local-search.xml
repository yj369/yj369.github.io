<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Flutter Widgets</title>
    <link href="/2022/06/26/Flutter-Widgets/"/>
    <url>/2022/06/26/Flutter-Widgets/</url>
    
    <content type="html"><![CDATA[<h1 id="Flutter-Widget"><a href="#Flutter-Widget" class="headerlink" title="Flutter Widget"></a>Flutter Widget</h1><p>在开发前端UI的时候，最常用到一个术语就是组件 (Component)。组件的概念中包括了UI组件以及控制组件但并不仅此而已。同理，在Flutter中，几乎所有的对象都是“组件”，但我们并不称它为“组件”，而是部件 (Widget)。在区别上, Component 和 Widget 的关系就是 Component &gt; Widget. 什么意识咧？举个例子，一个MacBook从外观上来看是分为 Screen 和 Keyboard，它们是组成外观上的Components。键盘上又有好多好多个 keys, 这些 keys 就是一个个的 Widgets 来组成一个完整的 Keyboard。每一个 Key Widget 都是独立的 UI (return, shift), Functionality (你可以敲它)，甚至还有手势检测的功能 (double press, long press 等等…).</p><blockquote><p>那么，Flutter中就是通过 Widgets 嵌套 Widgets 的方式来进行UI构建。Everything is Widget in Flutter!</p></blockquote><h2 id="Widget-Interface"><a href="#Widget-Interface" class="headerlink" title="Widget Interface"></a>Widget Interface</h2><p>在 Flutter 中，Widget 的主要作用就是用于描述一个UI元素的配置信息。所谓的配置信息就是 Widget 所接收到的参数， 如文本内容，字体大小，对齐方式等。但是要清楚的一点就是，配置信息并不一定就是其在设备屏幕上最终的渲染效果。</p><p>下面的代码内容是 Flutter 的 Widget源代码 (当然是删掉了一大堆没用的 comments)。既然要学习，就要养成深入到源代码的习惯。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@immutable</span> <span class="hljs-comment">// 不可变的</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DiagnosticableTree</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> Widget(&#123; <span class="hljs-keyword">this</span>.key &#125;);<br><br>  <span class="hljs-keyword">final</span> Key? key;<br><br>  <span class="hljs-meta">@protected</span><br>  <span class="hljs-meta">@factory</span><br>  <span class="hljs-built_in">Element</span> createElement();<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">String</span> toStringShort() &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> type = objectRuntimeType(<span class="hljs-keyword">this</span>, <span class="hljs-string">&#x27;Widget&#x27;</span>);<br>    <span class="hljs-keyword">return</span> key == <span class="hljs-keyword">null</span> ? type : <span class="hljs-string">&#x27;<span class="hljs-subst">$type</span>-<span class="hljs-subst">$key</span>&#x27;</span>;<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> debugFillProperties(DiagnosticPropertiesBuilder properties) &#123;<br>    <span class="hljs-keyword">super</span>.debugFillProperties(properties);<br>    properties.defaultDiagnosticsTreeStyle = DiagnosticsTreeStyle.dense;<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-meta">@nonVirtual</span><br>  <span class="hljs-built_in">bool</span> <span class="hljs-keyword">operator</span> ==(<span class="hljs-built_in">Object</span> other) =&gt; <span class="hljs-keyword">super</span> == other;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-meta">@nonVirtual</span><br>  <span class="hljs-built_in">int</span> <span class="hljs-keyword">get</span> hashCode =&gt; <span class="hljs-keyword">super</span>.hashCode;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> canUpdate(Widget oldWidget, Widget newWidget) &#123;<br>    <span class="hljs-keyword">return</span> oldWidget.runtimeType == newWidget.runtimeType<br>        &amp;&amp; oldWidget.key == newWidget.key;<br>  &#125;<br><br>  ...<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="immutable"><a href="#immutable" class="headerlink" title="@immutable"></a>@immutable</h3><p>immutable 的字面意思就是代表该 Widget 是不可变的, 那么在 Widget 的内部都必须使用 <code>final</code> 来修饰每一个属性 (properties)。这么设计的目的就是防止当 Widget 的属性发生变化而导致对整个组件的重构。</p><h3 id="DiagnosticableTree"><a href="#DiagnosticableTree" class="headerlink" title="DiagnosticableTree"></a>DiagnosticableTree</h3><p>从源代码的定义中可以看出，Widget class 继承于 <code>DiagnosticableTree</code>, 这个 DiagnosticableTree (诊断树) 的主要作用就是提供了调试信息。</p><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>在使用 Class 的方式开发 React 组件的时候，我们是可以声明组件的 update hook 函数的。hook 函数也叫钩子函数，或生命周期函数，主要的作用用于控制组件的声明周期。比如，我们在 Input 组件中输入了文字，那么就可以使用 shouldComponentUpdate(nextProps, nextState) 函数来捕获和处理对应的业务代码。(徒徒要是不知道就说明没有认真学react，不过没关系)</p><p>那么 Widget class 中的 key 的作用其实类似于上面的逻辑，它就是用于决定是否在下一次 <code>build</code> 的时候复用旧的 Widget，主要的决定条件在 canUpdate(Widget oldWidget, Widget newWidget) 函数中。</p><h3 id="canUpdate"><a href="#canUpdate" class="headerlink" title="canUpdate()"></a>canUpdate()</h3><p>canUpdate 函数的作用就是在 <code>build</code> 时是否在新的 Widget 对象上去更就 UI 树上所对应的对象配置。当 <code>newWidget</code> 和 <code>oldWidget</code> 的 <code>runtimeType</code> 和 <code>key</code> 都对等时生效。</p><h3 id="createElement"><a href="#createElement" class="headerlink" title="createElement()"></a>createElement()</h3><p>createElement 函数的作用就是隐性的帮助我们创建好对应的 Elements。在实际的开发过程中，我们经常需要向一个 Widget 添加大量的 Elements，如 Item List 中的 Items。</p><h3 id="debugFillProperties"><a href="#debugFillProperties" class="headerlink" title="debugFillProperties"></a>debugFillProperties</h3><p>debugFillProperties(DiagnosticPropertiesBuilder properties) 这个方法是一个 Override 的方法，但其作用就是用于设置 DiagnosticableTree 的特性。</p><h3 id="nonVirtual"><a href="#nonVirtual" class="headerlink" title="@nonVirtual"></a>@nonVirtual</h3><p>@nonVirtual 修饰符的作用是让每一个 <code>Derived Class</code> 的类都不能 override 带有这个修饰符的函数。Which made a function is not overridable from derived classes.</p><h2 id="Flutter-Widget-的渲染机制-Widget-Trees"><a href="#Flutter-Widget-的渲染机制-Widget-Trees" class="headerlink" title="Flutter Widget 的渲染机制 - Widget Trees"></a>Flutter Widget 的渲染机制 - Widget Trees</h2><p>当一个 Widget 在 Flutter 应用上被渲染出来时，系统本身也创建出了三棵不同的结构树:</p><ul><li>Widget</li><li>Element</li><li>RenderObject</li></ul><p>Widget Tree 是 Flutter 的核心部分，是用户界面的不可变配置信息 (immutable configuration information). 但是咱先前叙述过，它并不代表最终的渲染成效。</p><p>Element Tree 是由 Widget Tree 生成而来，唯一的区别就是 Element Tree 中的每一个节点都是实例化的 Widget 节点对象，通过 Widget 的 createElement() 方法在特定位置通过 Widget 的配置数据生成。</p><p>Element Tree 生成了 Render Tree, 其作用是用于界面的布局和绘制，同时也保存了元素的大小和布局等信息。Render Tree 才是最终用于布局和渲染的地方。</p><p>那讲了这么多的概念，师傅 copy 了官网的的一段 <a href="https://docs.flutter.dev/resources/architectural-overview#build-from-widget-to-element">code</a> 来看看如何把上面的概念应用到实际的代码中去理解：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart">Container(<br>  color: Colors.blue,<br>  child: Row(<br>    children: [<br>      Image.network(<span class="hljs-string">&#x27;https://www.example.com/1.png&#x27;</span>),<br>      <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&#x27;A&#x27;</span>),<br>    ],<br>  ),<br>);<br></code></pre></td></tr></table></figure><p>代码本身的阅读并没有什么难度, Container 是一个 Widget，它的配置描述有 <code>color</code> 和 <code>child</code>.</p><p>由于 Container 设置了背景颜色，所以在底层（createElement），Container会创建一个新的对象 ColoredBox 来填充Container的背景。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">if</span> (color != <span class="hljs-keyword">null</span>)<br>  current = ColoredBox(color: color!, child: current);<br></code></pre></td></tr></table></figure><p>紧接着，child 接受一个 Row Widget。 Row Widget 内的 Image 通过 RawImage 来渲染图片，<br>而 Text 则是使用 RichText 来渲染对应的文本。那么它的最终生成的结构树就如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/yj369/image-host/flutter-trees.png" alt="flutter trees"></p><h2 id="StatelessWidget"><a href="#StatelessWidget" class="headerlink" title="StatelessWidget"></a>StatelessWidget</h2><p>为啥子师傅老喜欢在这里讲 React 的概念咧？因为 Flutter 的设计理念跟 React 有很多相似处。就好比现在要讲的 StatelessWidget。也许你还记得，师傅一直都只教你使用 function Container() 的方式去创建一个 React 组件。然而你不知道的是，这种方式就是所谓的 Stateless Component (无状态组件)。</p><p>顾名思义，StatelessWidget 就是不需要维护状态的 Widget，它继承于 Widget Class，而且重构了 createElement() 方法。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StatelessWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Widget</span> </span>&#123;<br>  <span class="hljs-comment">/// <span class="language-markdown">Initializes [key] for subclasses.</span></span><br>  <span class="hljs-keyword">const</span> StatelessWidget(&#123; Key? key &#125;) : <span class="hljs-keyword">super</span>(key: key);<br><br>  <span class="hljs-meta">@override</span><br>  StatelessElement createElement() =&gt; StatelessElement(<span class="hljs-keyword">this</span>);<br><br>  <span class="hljs-meta">@protected</span><br>  Widget build(BuildContext context);<br>&#125;<br></code></pre></td></tr></table></figure><p>在实际的开发中，我们一般开发中，StatelessWidget 的用法是使用 <code>build</code> 方法来嵌套其他 Widget 来构建 UI。下面是 Flutter 默认提供的 counter App 的代码块：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(<span class="hljs-keyword">const</span> MyApp());<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br><br>  <span class="hljs-keyword">const</span> MyApp(&#123;Key? key&#125;) : <span class="hljs-keyword">super</span>(key: key);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> MaterialApp(<br>      title: <span class="hljs-string">&#x27;Flutter Demo&#x27;</span>,<br>      theme: ThemeData(<br>        primarySwatch: Colors.blue,<br>      ),<br>      home: <span class="hljs-keyword">const</span> MyHomePage(title: <span class="hljs-string">&#x27;Flutter Demo Home Page&#x27;</span>),<br>      debugShowCheckedModeBanner: <span class="hljs-keyword">false</span>,<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看到这，你没有太关注 Widget build(BuildContext context) 中的 <code>context</code>, 那么这个 context 参数是 BuildContext Class的一个实例 (Instance), 其表示当前 Widget 在整个 Widget Tree 中的上下文。这个概念很像 JavaScript 中的 DOM Tree，当我们拿到某一个Element的 context之后，就可以通过当前的 context 去寻找其他父级组件或者子类组件并进行相关的操作。自然，这个 Context 也可以对自身进行一个合理范围内的操作。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BuildContext</span> </span>&#123;<br><br>  Widget <span class="hljs-keyword">get</span> widget;<br><br>  BuildOwner? <span class="hljs-keyword">get</span> owner;<br><br>  <span class="hljs-built_in">bool</span> <span class="hljs-keyword">get</span> debugDoingBuild;<br><br>  RenderObject? findRenderObject();<br><br>  Size? <span class="hljs-keyword">get</span> size;<br><br>  ......<br><br>  T? findAncestorWidgetOfExactType&lt;T <span class="hljs-keyword">extends</span> Widget&gt;();<br><br>  T? findAncestorStateOfType&lt;T <span class="hljs-keyword">extends</span> State&gt;();<br><br>  T? findRootAncestorStateOfType&lt;T <span class="hljs-keyword">extends</span> State&gt;();<br><br>  T? findAncestorRenderObjectOfType&lt;T <span class="hljs-keyword">extends</span> RenderObject&gt;();<br><br>  <span class="hljs-keyword">void</span> visitAncestorElements(<span class="hljs-built_in">bool</span> <span class="hljs-built_in">Function</span>(<span class="hljs-built_in">Element</span> element) visitor);<br><br>  <span class="hljs-keyword">void</span> visitChildElements(ElementVisitor visitor);<br><br>  <span class="hljs-keyword">void</span> dispatchNotification(Notification notification);<br><br>  ......<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="StatefulWidget"><a href="#StatefulWidget" class="headerlink" title="StatefulWidget"></a>StatefulWidget</h2><p>StatefullWidget 和 StatelessWidget 实现类似，但它返回的 Element 对象不同且添加了一个新的接口 createState()。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StatefulWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Widget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> StatefulWidget(&#123; Key key &#125;) : <span class="hljs-keyword">super</span>(key: key);<br>    <br>  <span class="hljs-meta">@override</span><br>  StatefulElement createElement() =&gt; StatefulElement(<span class="hljs-keyword">this</span>);<br>    <br>  <span class="hljs-meta">@protected</span><br>  <span class="hljs-meta">@factory</span><br>  State createState();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>createState()</code> 用于创建和 StatefulWidget 相关的状态，它在 StatefulWidget 的生命周期中可能会被多次调用。如，在一个 Item List 中添加2个除了颜色其他都一样的两个 Item Box, 那么 Flutter 就会调用 createState 方法为每个 Item Box Widget 生成独立的 State 实例。</p>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
